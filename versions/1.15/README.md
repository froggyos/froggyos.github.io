# froggyOS Documentation

## Info
* in paths, `.` will be replaced with the current directory
* programs can *only* be written in designated directories
* you can press the `DEL` key to escape programs (ex. an infinite loop)
* if a FroggyScript program exits with an error, the command `[[BULLFROG]]gotoprogramline [program] [line with error]` will be put into your command history
* file types are inferred based on file location
* For whatever reason, if there is no typeable line in the terminal, press `SHIFT + ENTER` to create a typeable line
### Paths
Paths have three parts, the drive, the directory, and the file name.
```
┌───────────Full Path──────────┐
├─────Location─────┐           │
[drive]:/[directory]/[file name]
```

## Palette Conventions
There are no set colors that you must have, but these are the color conventions.
* `00` - black
* `01` - blue
* `02` - green
* `03` - cyan
* `04` - red
* `05` - magenta
* `06` - orange/brown
* `07` - light grey
* `08` - dark grey
* `09` - light blue
* `10` - light green
* `11` - light cyan
* `12` - light red
* `13` - light magenta
* `14` - light orange/yellow
* `15` - white

### Current Color Palettes
* standard
* revised
* cherry
* swamp
* swamp-revised
* neon

## Aliases
* changelanguage -> lang
* clear -> cl
* clearstate -> cls
* croak -> c
* formattime -> ft
* hatch -> ch
* help -> ?
* hop -> h
* list -> ls
* listdrives -> ld
* loadstate -> lds
* macro -> /
* meta -> m
* metaprop -> mp
* opendocumentation -> docs
* savestate -> svs
* spawn -> s
* swimto -> st

## Translating froggyOS into Different Languages
* The `lbh` file in the `Config:/langs` directory is what holds the indexes for translation. **Do not edit this file unless you deliberately want to mess up froggyOS.**
    * Languages file names are 3 letter abbreviations of the language name.
* To add a new language, clone the `lbh`, or `language build helper` file, which contains **translation descriptors** (prefixed with `T_`), which give you an idea of what the intended meaning of the text.
* Set the language to `lbh` to see which translation descriptors are used where in froggyOS. If there are missing translation descriptors at the end of a file, the English translation will be used.
    * If a language file does not meet requirements (valid name declaration, correct file length), it will be invalid and unable to be used.
* The **name declaration** must be the first line of the file, and must be in the format `!LANGNAME: [language name]`. For example, the name declaration for the `eng` file is `!LANGNAME: English`.
* If the default language is invalid, froggyOS will automatically revert to the `lbh` language file.
* If a text results in `Index Missing! -> [translation descriptor]`, this means that the translation descriptor is missing from the language file.
* Some translation descriptors include `|||[]|||` in it. This must be included in order to reference the descriptor. This is because between the `[]` a string can be placed that will show in the final translation. For example, if you used `T_greeting_2 |||[3 million]|||`, it would return in the `eng` translation as `* Welcome to froggyOS, version 3 million *`. You can use only one of these per descriptor.

## Command Help
### formattime
The all instances of the following characters (or character sequences) will be replaced with their respective values. Place a `!` before the character to escape it.
#### Date
* weekday
    * `w` - short weekday (Mon, Tues)
    * `W` - long weekday (Monday, Tuesday)
* `y` - year
* month
    * `mn` - month number (01, 02)
    * `mnu` - month number unpadded (1, 2)
    * `ms` - month short (Jan, Feb)
    * `M` - month long (January, February)
* day
    * `d` - day (01, 02)
    * `du` - day unpadded (1, 2)
    * `D` - ordinal day (1st, 2nd)

#### Time
* hour
    * `h` - 24 hour (00, 01, ... 22, 23)
    * `hu` - 24 hour unpadded (0, 1, ... 22, 23)
    * `H` - 12 hour (01, 02, ... 11, 12)
    * `Hu` - 12 hour unpadded (1, 2, ... 11, 12)
* minute
    * `m` - minute (00, 01)
    * `mu` - minute unpadded (0, 1)
* second
    * `s` - second (00, 01)
    * `su` - second unpadded (0, 1)
* `a` - AM/PM
* `z` - timezone

### hop
* `hop ~` will take you to the root directory of the current drive
* `hop -` will take you to the previous directory

### metaprop
Properties:
* read - If this file can be read. This includes being able to run the program or list file contents with the `spy` command.
    * when a file is cloned, this property will be set to `true`.
* write - If this file can be written to. This includes being able to edit the file or delete it.
    * when a file is cloned, this property will be set to `true`.
* hidden - If this file is hidden. This will prevent the file from being acted upon (ie. cannot be edited).
* transparent - This file will not show in the directory or in lists, but can be acted upon (ie. can be edited).
    * when a file is cloned, this property will be set to `false`.

## Macros
* Macros are written in the `D:/Macros` directory
* each line in a macro file is a command that will be executed
* to add an alias to a macro, the **first line must** be `![alias]`. You can add only one alias per macro.
* to use file arguments inside of a macro, use `$[file argument number]` (ex. `$1`)

## Settings Directory
If you edit the `Settings:` drive directly, some settings won't apply until you reload the froggyOS state. An easy way to do this would be to run the `reload` macro.

## Bugs
* parsing is broken in the prefunction lol

## Trusting Programs
To trust a program, you must add its file name in the `D:/trusted_files` file. This will allow the program to have extended control over the operating system. Trusted programs are refreshed **only** on hard restarts (reload the page).

## froggyOS Structured Data Storage (fSDS)
fSDS is a way to store key-value pairs in a file. A value can be one of four types: `String`, `Number`, `Boolean`, or `Array`. fSDS is most prominently used to store file data in the `Config:/program_data` directory, but may be used in other places as well. You cannot store arrays inside of arrays.
### Non-Array
```
KEY [key name] TYPE [type (String/Number/Boolean)] VALUE [value] END
```
### Array
```
KEY [key name] TYPE Array START
0 TYPE [type (String/Number/Boolean)] VALUE [value]
1 TYPE [type (String/Number/Boolean)] VALUE [value]
(...)
KEY [key name] TYPE Array END
```
## Lilypad keybinds
Lilypad is the text editor in froggyOS. It has a few keybinds that you can use to make editing easier.
### Saving
* `ESC` - save and exit
* `SHIFT + ESC` - exit without saving

### Navigation
* `ArrowUp` - move cursor up one line
* `ArrowDown` - move cursor down one line

* `Shift + ArrowUp` - move cursor to end of previous line
* `Shift + ArrowDown` - move cursor to beginning of next line

* `CTRL + ArrowUp` - Move to first line
* `CTRL + ArrowDown` - Move to last line

* `ALT + ArrowUp` - Move current line up one line
* `ALT + ArrowDown` - Move current line down one line

* `CTRL + Q` - Move to beginning of current line
* `CTRL + E` - Move to end of current line

## Selection
* `Shift + ArrowLeft` - select one character to the left
* `Shift + ArrowRight` - select one character to the right

* `CTRL + Shift + ArrowLeft` - select one word to the left
* `CTRL + Shift + ArrowRight` - select one word to the right

* `CTRL + A` - select all text on the current line

## Creation
* `Enter` - insert a new line at the current cursor position
* `Shift + Enter` - create a new line below the current line
* `DEL` - delete current line
## Other
* `CTRL + C` - copy selected text
* `CTRL + X` - cut selected text
* `CTRL + V` - paste text from clipboard

# FroggyScript Documentation
## Notes
* `[argument=default_value]` denotes a default argument value
* `:[character]` denotes a specific type input
    * `T` - placeholder; used in documentation **only** to show that the type should be specified
    * `*` - any type
    * `S` - String
    * `N` - Number
    * `B` - Boolean
    * `A` - Array
    * `R` - Identifier Reference
    * `U` - Undefined
* error position is unreliable
* error lines are not always accurate ??? whyyy idk 
* After a keyword, you must used `,` to separate arguments. ex. `ask %name , "?"`. The whitespace around the comma is not required, but is recommended for readability.

## General Utilities
### Comments
```
## comment!
str test = "hello" ## this is a comment
```
### Prematurely End the Program
```
endprog
```
### Wait
```
wait [time]

wait 1000
wait number
```
### Clear Screen
```
clearterminal
```
### Preset Variables
These variables are immutable.
```
Pi:N - 3.141592653589793
ProgramName:S - name of the current program
```
<!-- Time_MsEpoch:N - time since epoch (January 1, 1970) in milliseconds
Time_OSRuntime:N - OS uptime in milliseconds
Time_ProgramRuntime:N - program uptime in milliseconds
Undefined:U - undefined -->
## Identifier References
To pass a reference to a variable, prefix the name with the `%` symbol. This is useful for getting variable names, like in the `ask` or `prompt` keywords.
## Calculation
To perform mathematical operations, you must surround the expression with `{}`. You cannot perform string comparison using calculations, use the `>eq` method instead. You may use variables inside of calculations, but you cannot use methods.
```
num i = 5
num j = 10

out {i + j} ## outputs 15

out i + j ## outputs 5
```
These are the valid operators in calculations:
* `+` - addition
* `-` - subtraction
* `*` - multiplication
* `/` - division
* `^` - exponentiation
* ` == ` - equality
* ` != ` - inequality
* ` < ` - less than
* ` > ` - greater than
* ` <= ` - less than or equal to
* ` >= ` - greater than or equal to
The whitespace around the comparison operators is **required**.
## Oneliners
The `.` (oneliner) operator is used to perform methods without needing to use another keyword.
```
rect rectangle = $0, 0, 20, 20$
do rectangle>render
```
## Variables
### Create a Variable
#### String
Make a variable immutable by prefixing the keyword with `c` (ex. `cstr`).
```
str [variable name] = [value]

str test = 'single'
str test = "double"
str test = "multiple words"

-- string literals
num age = 20
str output = "i am $|age| years old"
```
#### Number
```
num [variable name] = [value]

num i = 9
```
#### Boolean
```
bln [variable name] = [value]

bln test = true
```
#### Array
* Indexing starts at `0`.
* To create an empty array, do `arr [variable_name] = $ $`.
```
arr [variable name] = $[value], [value], ...$

arr test1 = $1, 2, 3, 4, 5$
arr test2 = $"a", "b", "c", "d", "e"$
arr test3 = $"a", 1, true, 2.5, "b"$
```

### Edit a Variable
You may only edit a variable if the value is of the same type.
```
set [variable name] = [value]

num i = 5
str test = "text"

set test = "many word"
set i = i + 1

set i = test ## typeError
```
You can also use the `<` (reflexive) operator and a variable reference to set a value to itself.
```
str string = "hello, "
<%string>append("world!")
## "hello, world!"
```
### Delete a Variable
```
free [variable name:R]

free %test
```

## Output
### Basic Output
```
out [argument:S|B|N]

out variable_name
out "text"
out "more text"
out 1
out false
```
Outputting a string with length 0 will result in `(Empty String)` being outputted. To output a blank line, use `out EmptyLine`.
```
out "" ## outputs (Empty String)
out EmptyLine ## outputs a blank line
```
### Formatted Output
#### General
* index `0` is the 1st character.
* There is less than normal error checking on formatting, so make sure it's correct.
```
outf [format],[text]

outf "t=c01" , "this is blue text"
outf "b=c00" , "this is a black background"
outf "t=c06, b=c01" , "this is brown text on a blue background"
outf "t=c01, tr=0-21" , "from char 0 to char 21, the text will be blue" 
outf "t=c01, tr=4-48 | b=c04, br=57-91" , "from the char 4 to char 48, the text will be blue. AND from char 57 to char 91 the background will be red"
```
#### Formatting
* **rules** are delimited by the pipe operator: `{[property]=[value] | [property]=[value], [property]=[value]}`
* **subrules** are delimited by the comma operator, and occur inside of **rules**: `{[property]=[value],[property]=[value]}`
    * If a range is not specified, it will apply to the entire string
    * The value for Italic is `1` to be enabled, and `0` to be disabled
* valid properties:
    * `t` - text color
    * `b` - background color
    * `i` - italic
    * `tr` - text color range
    * `br` - background color range
    * `ir` - italic range
<!-- 
### Errors
Errors do not end the program early, follow with the `endprog` keyword to do so.
#### Basic Error
```
error [error message]

error "this is an error message"

-- test program
error "this is an error message"
str test = "hello world!"
out test
endprog

-- when ran
C:/Home> st [program name]
!!ERROR!! - this is an error message
hello world!
C:/Home>
``` -->
## Input
### Define a File Argument
File arguments are passed in the terminal when running the program. The order they are defined will determine the order that they are passed in the terminal. You cannot use spaces in file arguments. The `filearg` keyword will replace itself with the line `set [variable name] = "[input]">coerce("[variable type]")` after the input is received.
```
filearg [variable name:R]

## default usage
str name = ""
num age = 0
filearg %name
filearg %age
out "hello I am $|Filearg_name| and I am $|Filearg_age| years old"

## when running the program
C:/Home> st [program name] [arg1] [arg2]
C:/Home> st [program name] froggy 7
 hello I am froggy and I am 7 years old
```
### Typeable Input
The `ask` keyword will not create a new variable and cannot overwrite other variable values, even if that variable is mutable. After input, the interpreter will replace the `ask` keyword line with `set [variable name] = "[input]">coerce("[variable type]")`.
```
ask [variable:R],[prefix:S]

ask %name , "?"

## different line
str name = ""
out "What is your name?"
ask %name , "?"
out 'Hello $|name|!'

## same line
str name = ""
ask %name , "What is your name?"
out 'Hello $|name|!'

## in the terminal, different line
C:/Home> st [program name]
What is your name?
? Froggy
 Hello Froggy!

## in the terminal, same line
C:/Home> st [program name]
What is your name? Froggy
 Hello Froggy!
```

### Input with Navigable Options
```
prompt [variable:R] , [default highlighted option:N] , [options:A]

str output = ''
prompt %output , 0 , $'hello', "world!", "I am froggy!"$
```
## Methods
If no arguments are passed, you may omit the parentheses. Arguments are separated by `,`.
### Multipule Types
#### coerce
Converts a variable to a different type. The type must be one of the following: `String`, `Number`, `Boolean`.
##### String → Number
```
out "42">coerce("Number")
## 42

out "not a number">coerce("Number")
## TypeError
```
##### String → Boolean
```
out "true">coerce("Boolean")
## true

out "false">coerce("Boolean")
## false

out "not a boolean">coerce("Boolean")
## TypeError
```
##### String → String
```
out "hello">coerce("String")
## "hello"
```
##### Number → String
```
out 42>coerce("String")
## "42"
```
##### Number → Boolean
```
out 123>coerce("Boolean")
## true

out 1>coerce("Boolean")
## true

out 0>coerce("Boolean")
## false

out -1>coerce("Boolean")
## false

out -123>coerce("Boolean")
## false
```
##### Number → Number
```
out 42>coerce("Number")
## 42
```
##### Boolean → String
```
out true>coerce("String")
## "true"

out false>coerce("String")
## "false"
```
##### Boolean → Number
```
out true>coerce("Number")
## 1

out false>coerce("Number")
## 0
```
##### Boolean → Boolean
```
out true>coerce("Boolean")
## true
```
#### type
Returns the type of the variable as a string.
```
str string = "hello"
out string>type
## "String"

num number = 5
out number>type
## "Number"

bln boolean = true
out boolean>type
## "Boolean"

arr array = $1, 2, 3, 4, 5$
out array>type
## "Array"
```
### String
#### eq
Tests if two strings are equal.
```
str test = "hello"
str test2 = "hello"
out test>eq(test2)
```
#### neq
Tests if two strings are not equal.
```
str test = "hello"
str test2 = "world"
out test>neq(test2)
```
#### append
Adds a string to the end of another string.
```
str test = "hello"
str test2 = " world"
out test>append(test2)
## "hello world"
```
#### length
Returns the length of a string.
```
str test = "this is a long string"
out test>length
## 22
```
#### repeat
Repeats a string a certain number of times.
```
str test = "hello"
out test>repeat(5)
## "hellohellohellohellohello"
```
### Number
#### abs
Returns the absolute value of a number.
```
num test = -5
out test>abs
## 5
```
#### truncate
Truncates a number to the nearest place value. Default is `0`.
```
out 5.5>truncate
## 5

out 5.5>truncate(1)
## 5.5

out 3.1203>truncate(3)
## 3.12

out 54.291>truncate(3)
## 54.291
```
#### round
Rounds a number to the nearest integer.
```
out 10.203>round
## 10
```
#### mod
Returns the modulus of a number.
```
out 10>mod(3)
## 1
```
#### inc
Increments a number by `1`.
```
out 1>inc
## 2
```
#### dec
Decrements a number by `1`.
```
out 5>dec
## 4
```

#### add
Adds two numbers together.
```
out 5>add(10)
## 15
```
#### sub
Subtracts two numbers.
```
out 10>sub(5)
## 5
```
#### mul
Multiplies two numbers.
```
out 5>mul(10)
## 50
```
#### div
Divides two numbers.
```
out 10>div(5)
## 2

out 10>div(0)
## Infinity
```
### Boolean
#### flip
Flips a boolean value.
```
bln test = true
out test>flip
## false
```
### Array
#### append
Adds a value to the end of an array.
```
arr test = $1, 2, 3, 4, 5$
out test>append(6)
## $1, 2, 3, 4, 5, 6$
```
#### join
Joins an array into a string. Default delimiter is `,`.
```
arr test = $1, 2, 3, 4, 5$
out test>join
## "1,2,3,4,5"

arr test2 = $1, 2, 3, 4, 5$
out test2>join(" and ")
## "1 and 2 and 3 and 4 and 5"
```
#### length
Returns the length of an array.
```
arr test = $1, 2, 3, 4, 5$
out test>length
## 5
```
#### index
Returns the value at a specific index.
```
arr test = $1, 2, 3, 4, 5$
out test>index(2)
## 3
```
## Functions
### Create a Function
#### No Arguments
```
func [func name]()
    [code]
endfunc

func name()
    out "hello"
endfunc
```
#### Arguments
```
func [func name]([arg1:T],[arg2:T],...,[argN:T])
    [code]
endfunc

func name(str:S)
    out "hello $|str|!"
endfunc
```
#### Return Values
If the *last parsed token* in a function is `return`, you can retrieve that value for use. `![function name]` will resolve as the return value of the specified function, and then discard the return value.
```
func name()
    return 5
endfunc

call @name()
num i = !name ## i = 5
out !name ## ReferenceError, value was already returned
```
### Call a Function
#### No Arguments
Currently they do require the parenthesis but i wanna make it not
```
call @[func name]()

call @name()
```
#### Arguments
```
call @[func name]([arg1],[arg2],...,[argN])

call @name("hello","world!")
```

## Control Flow
### If Statement
```
if [condition]  
    [code]
endif

if variable_name>eq('value')
    set variable_name = 'new value'
endif

if [condition]
    [if true]
else
    [if false]
endif

if {variable_name == 4}
    out "something"
else
    out "something else"
endif
```

### Loops
#### Standard Loop
When the `loop` keyword is read, if the condition is true, the code will continue. If it is false, the interpreter will skip the line after the next matching `endloop` keyword and the code inside will not be run. When an `endloop` keyword is read, the interpreter will move to the matching `loop` keyword.
```
loop [condition:N|B]
    [code]
endloop

## Boolean condition
loop {i < 5}
    out i
    set i = {i + 1}
endloop

## Number condition
loop 10
    out "hello"
endloop
## will output "hello" 10 times

num i = 0
num j = 0
num number = 0
loop {i < 5}
    loop {j < 4}
        set number = {number + 1}
        set j = {j + 1}
    endloop
    set i = {i + 1}
    set j = 0
endloop
```

#### Quickloop
Quickloops are different from standard loops in that the entire loop is executed *almost instantly*, while standard loops are executed one line at a time.
```
quickloop [condition:N|B]
    [code]
endquickloop

## Boolean condition
quickloop {i < 5}
    out i
    set i = {i + 1}
endquickloop

## Number condition
quickloop 100
    out "hello"
endquickloop
## outputs "hello" 100 times in a row
```
## Program Data
<!-- ### Saving Data
Saves the contents of `[variable]` to the corresponding file in the `Config:/program_data` file. The key cannot contain spaces.
```
savedata [key] [value]
``` -->

### Loading Data
<!-- From the corresponding `Config:/program_data` file, loads the contents of entry of `[variable]` to the variable called `[variable]`
```
loaddata [variable] [key]
``` -->
## Imports
Imports are a way to extend the functionality of FroggyScript. Imports must be defined at the top of the file.
### Import a Module
```
import [import name:S]

import "graphics"
```
### Imports List & Documentation
* [graphics](https://rus1130.github.io/projects/mdparser.html?url=https://froggyos.github.io/versions/1.15/extra-docs/graphics.md&toc=true)
* [config](https://rus1130.github.io/projects/mdparser.html?url=https://froggyos.github.io/versions/1.15/extra-docs/config.md) (currently not implemented)
### Publish an Import
* To publish an import so every froggyOS user can use it, send an email to `froggyoscom+import@gmail.com` with a `.js` file of the import and a `.md` file with the documentation.
# froggyOS Technical Information
## Startup Sequence
1. Load any state if it exists from `localStorage`
2. Get the user config from `Config:/user`
3. Set the program list
4. Update date and time
5. Change the color palette
6. Create the color palette bar
7. Set trusted files    
8. Validate current language
Along with the startup sequence, there are two intervals, `configInterval` and `dateTimeInterval`. The `configInterval` updates the user config and program list every 1 millisecond, while the `dateTimeInterval` updates the date and time every 100 milliseconds.
## Types of Errors
### In-Operating System Errors
* `TypeError` - The type of a variable is not what was expected.
* `SyntaxError` - The syntax of the code is not valid.
* `ReferenceError` - The thing that was referenced is not defined, not accessible, or cannot be changed.
* `CalculationError` - The calculation could not be performed.
* `EvaluationError` - The evaluation of a token failed.
* `ImportError` - Import could not be loaded, or was already loaded.
* `RangeError` - The range of a value is out of its expected bounds.
* `StateError` - The least specific error type. The program is not in a valid state to proceed.
### Out-of-Operating System Errors
These are errors that are caused by bad JavaScript introduced by the user.
* `TokenizatorError` - The tokenizer could not tokenize. Most likely caused by no Keywords being found.
* `MethodParseError` - Token is undefined after parsing methods. Most likely caused by a method having no return value.
<!--
overhaul inclusions in translation descriptors
[T#:{value}]
# = number
this allows for multiple inclusions per descriptor
-->
# Other
If you have any questions, comments, or suggestions, email `froggyoscom+other@gmail.com`. If you have any concerns or found a bug, [open an issue on the GitHub repository](https://github.com/froggyos/froggyos.github.io/issues).