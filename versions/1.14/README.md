# froggyOS Documentation

* in paths, `.` will be replaced with the current directory
* programs can *only* be written in designated directories
* you can press the `DEL` key to escape programs (ex. an infinite loop)
* press `SHIFT + ESC` to exit lilypad (text editor) without saving
<!-- * if a FroggyScript program exits with an error, the command `[[BULLFROG]]gotoprogramline [program] [line with error]` will be put into your command history -->
* file types are inferred based on file location

## Palette Conventions
There are no set colors that you must have, but these are the color conventions.
* `00` - black
* `01` - blue
* `02` - green
* `03` - cyan
* `04` - red
* `05` - magenta
* `06` - orange/brown
* `07` - light grey
* `08` - dark grey
* `09` - light blue
* `10` - light green
* `11` - light cyan
* `12` - light red
* `13` - light magenta
* `14` - light orange/yellow
* `15` - white

### Current Color Palettes
* standard
* revised
* cherry
* swamp
* swamp-revised
* neon

## Aliases

* changelanguage -> lang
* clear -> cl
* clearstate -> cls
* croak -> c
* formattime -> ft
* hatch -> ch
* help -> ?
* hop -> h
* list -> ls
* listdrives -> ld
* loadstate -> lds
* macro -> /
* meta -> m
* metaprop -> mp
* opendocumentation -> docs
* savestate -> svs
* spawn -> s
* swimto -> st

## Translating froggyOS into Different Languages
* The `lbh` file in the `Config:/langs` directory is what holds the indexes for translation. **Do not edit this file unless you deliberately want to mess up froggyOS.**
    * Languages file names are 3 letter abbreviations of the language name.
* To add a new language, clone the `lbh`, or `language build helper` file, which contains **translation descriptors** (prefixed with `T_`), which give you an idea of what the intended meaning of the text.
* Set the language to `lbh` to see which translation descriptors are used where in froggyOS. If there are missing translation descriptors at the end of a file, the English translation will be used.
    * If a language file does not meet requirements (valid name declaration, correct file length), it will be invalid and unable to be used.
* The **name declaration** must be the first line of the file, and must be in the format `!LANGNAME: [language name]`. For example, the name declaration for the `eng` file is `!LANGNAME: English`.
* If the default language is invalid, froggyOS will automatically revert to the `lbh` language file.
* If a text results in `Index Missing! -> [translation descriptor]`, this means that the translation descriptor is missing from the language file.
* Some translation descriptors include `|||[]|||` in it. This must be included in order to reference the descriptor. This is because between the `[]` a string can be placed that will show in the final translation. For example, if you used `T_greeting_2 |||[3 million]|||`, it would return in the `eng` translation as `* Welcome to froggyOS, version 3 million *`. You can use only one of these per descriptor.

## Command Help
### formattime
The all instances of the following characters (or character sequences) will be replaced with their respective values. Place a `!` before the character to escape it.
#### Date
* weekday
    * `w` - short weekday (Mon, Tues)
    * `W` - long weekday (Monday, Tuesday)
* `y` - year
* month
    * `mn` - month number (01, 02)
    * `mnu` - month number unpadded (1, 2)
    * `ms` - month short (Jan, Feb)
    * `M` - month long (January, February)
* day
    * `d` - day (01, 02)
    * `du` - day unpadded (1, 2)
    * `D` - ordinal day (1st, 2nd)

#### Time
* hour
    * `h` - 24 hour (00, 01, ... 22, 23)
    * `hu` - 24 hour unpadded (0, 1, ... 22, 23)
    * `H` - 12 hour (01, 02, ... 11, 12)
    * `Hu` - 12 hour unpadded (1, 2, ... 11, 12)
* minute
    * `m` - minute (00, 01)
    * `mu` - minute unpadded (0, 1)
* second
    * `s` - second (00, 01)
    * `su` - second unpadded (0, 1)
* `a` - AM/PM
* `z` - timezone

### hop
* `hop ~` will take you to the root directory of the current drive
* `hop -` will take you to the previous directory

### metaprop
Properties:
* read - If this file can be read. This includes being able to run the program or list file contents with the `spy` command.
    * when a file is cloned, this property will be set to `true`.
* write - If this file can be written to. This includes being able to edit the file or delete it.
    * when a file is cloned, this property will be set to `true`.
* hidden - If this file is hidden. This will prevent the file from being acted upon (ie. cannot be edited).
* transparent - This file will not show in the directory or in lists, but can be acted upon (ie. can be edited).
    * when a file is cloned, this property will be set to `false`.

## Macros
* Macros are written in the `D:/Macros` directory
* each line in a macro file is a command that will be executed
* to add an alias to a macro, the **first line must** be `![alias]`. You can add only one alias per macro.
* to use file arguments inside of a macro, use `$[file argument number]` (ex. `$1`)

## Settings Directory
If you edit the `Settings:` drive directly, some settings won't apply until you reload the froggyOS state. An easy way to do this would be to run the `reload` macro.

## Bugs
* i recoded froggyscript so idk

## Trusting Programs
To trust a program, you must add its file name in the `D:/trusted_files` file. This will allow the program to have extended control over the operating system. Trusted programs are refreshed **only** on hard restarts (reload the page).

## Load Order
1. Load OS state if it exists
2. Change color palette
3. Create the color palette bar
4. Set trusted files
5. Validate language files
6. Initiate the command line with `[[BULLFROG]]greeting`

## froggyOS Structured Data Storage (fSDS)
fSDS is a way to store key-value pairs in a file. A value can be one of four types: `String`, `Number`, `Boolean`, or `Array`. fSDS is most prominently used to store file data in the `Config:/program_data` directory, but may be used in other places as well. You cannot store arrays inside of arrays.
### Non-Array
```
KEY [key name] TYPE [type (String/Number/Boolean)] VALUE [value] END
```
### Array
```
KEY [key name] TYPE Array START
0 TYPE [type (String/Number/Boolean)] VALUE [value]
1 TYPE [type (String/Number/Boolean)] VALUE [value]
(...)
KEY [key name] TYPE Array END
```

# FroggyScript Documentation
## Notes
* `[argument=default_value]` denotes a default argument value
* `:[character]` denotes a specific type input
    * `T` - placeholder; used in documentation **only** to show that the type should be specified
    * `*` - any type
    * `S` - String
    * `N` - Number
    * `B` - Boolean
    * `A` - Array
    * `U` - Undefined

## General Utilities
### Comments
```
-- comment!
```
### Prematurely End the Program
```
endprog
```
### Wait
```
wait [time]

wait 1000
wait number
```
### Clear Screen
```
clearterminal
```
### Preset Variables
These variables are immutable.
```
Pi:N - 3.141592653589793
ProgramName:S - name of the current program
```
<!-- Time_MsEpoch:N - time since epoch (January 1, 1970) in milliseconds
Time_OSRuntime:N - OS uptime in milliseconds
Time_ProgramRuntime:N - program uptime in milliseconds
Undefined:U - undefined -->
## Calculation
To perform mathematical operations, you must surround the expression with `{}`. You cannot perform string comparison using calculations, use the `>eq` method instead.
```
num i = 5
num j = 10

out {i + j}
-- results in 15

out i + j
-- results in 5
```
## Variables
### Create a Variable
#### String
Make a variable immutable by prefixing the keyword with `c` (ex. `cstr`).
```
str [variable name] = [value]

str test = 'single'
str test = "double"
str test = "multiple words"

-- string literals
num age = 20
str output = "i am $|age| years old"
```
#### Number
```
num [variable name] = [value]

num i = 9
```
#### Boolean
```
-- boolean
bln [variable name] = [value]

bln test = true
```
#### Array
* Indexing starts at `0`.
* To create an empty array, do `arr [variable_name] = $ $`.
```
arr [variable name] = $[value], [value], ...$

arr test1 = $1, 2, 3, 4, 5$
arr test2 = $"a", "b", "c", "d", "e"$
arr test3 = $"a", 1, true, 2.5, "b"$
```

### Edit a Variable
You may only edit a variable if the value is of the same type.
```
set [variable name] = [value]

num i = 5
str test = "text"

set test = "many word"
set i = i + 1

set i = test
-- throws a TypeError
```

### Delete a Variable
```
free [variable name:S]

free "test"
```

## Output
### Basic Output
```
out [argument]

out variable_name
out "text"
out "more text"
out 1
```
<!-- ### Formatted Output
#### General
* index `0` is the 1st character.
* There is less than normal error checking on formatting objects, so make sure they're correct.
```
outf [format] [text]

outf {t=c01} "this is blue text"
outf {b=c00} "this is a black background"
outf {t=c06, b=c01} "this is brown text on a blue background"
outf {t=c01, tr=0-21} "from char 0 to char 21, the text will be blue" 
outf {t=c01, tr=4-48 | b=c04, br=57-91} "from the char 4 to char 48, the text will be blue. AND from char 57 to char 91 the background will be red"
```
#### Format Object
* `{}` is a formatting object
* **rules** are delimited by the pipe operator: `{[property]=[value] | [property]=[value], [property]=[value]}`
* **subrules** are delimited by the comma operator, and occur inside of **rules**: `{[property]=[value],[property]=[value]}`
    * If a range is not specified, it will apply to the entire string
    * The value for Italic is `1` to be enabled, and `0` to be disabled
* valid properties:
    * `t` - text color
    * `b` - background color
    * `i` - italic
    * `tr` - text color range
    * `br` - background color range
    * `ir` - italic range

### Errors
Errors do not end the program early, follow with the `endprog` keyword to do so.
#### Basic Error
```
error [error message]

error "this is an error message"

-- test program
error "this is an error message"
str test = "hello world!"
out test
endprog

-- when ran
C:/Home> st [program name]
!!ERROR!! - this is an error message
hello world!
C:/Home>
``` -->
## Input
### Define a File Argument
File arguments are passed in the terminal when running the program. The `filearg` keyword will create an **immutable** variable in the format of `filearg_[variable name]` and cannot override other variable values, even if that variable is mutable. The order they are defined will determine the order that they are passed in the terminal. You cannot use spaces in file arguments in the terminal.
```
filearg [variable name:S] [type:S]

-- default usage
filearg "name" "String"
filearg "age" "Number"
out "hello I am $|Filearg_name| and I am $|Filearg_age| years old"

-- when running the program
C:/Home> st [program name] [arg1] [arg2]
C:/Home> st about_froggy "froggy" 7
> hello I am froggy and I am 7 years old
```
### Typeable Input
The `ask` keyword will not create a new variable and cannot overwrite other variable values, even if that variable is mutable.
```
ask [variable:S] [prefix:S]

ask "name" "?"

str name = ""
out "What is your name?"
ask "name" "?"
out 'Hello $|name|!'

-- in the terminal
C:/Home> st [program name]
> What is your name?
? Froggy
> Hello Froggy!
```

### Input with Navigable Options
```
prompt [variable:S] [default highlighted option:N] [options:A]

str output = ''
prompt 'output' 0 $'hello', "world!", "I am froggy!"$
```
## Methods
If no arguments are passed, you may omit the parentheses. Arguments are separated by `,`.
### String
### Number
### Boolean
### Array
## Functions
### Create a Function
#### No Arguments
```
func [func name]()
    [code]
endfunc

func name()
    out "hello"
endfunc
```
#### Arguments
```
func [func name]([arg1:T],[arg2:T],...,[argN:T])
    [code]
endfunc

func name(str:S)
    out "hello $|str|!"
endfunc
```
#### Return Values
If the function ends in the keyword `return`, the value of whatever passed will be the return value.
```
func name()
    return 5
endfunc

num i = @name()
```
### Call a Function
#### No Arguments
Currently they do require the parenthesis but i wanna make it not
```
call @[func name]()

call @name()
```
#### Arguments
```
call @[func name]([arg1],[arg2],...,[argN])

call @name("hello","world!")
```

## Control Flow
### If Statement
```
if [condition]  
    [code]
endif

if variable_name>eq('value')
    set variable_name = 'new value'
endif

if [condition]
    [if true]
else
    [if false]
endif

if {variable_name == 4}
    out "something"
else
    out "something else"
endif
```

<!-- ### Loops
#### Standard Loop
```
loop [condition]
    [code]
endloop

loop i < 5
    out i
    set i = i + 1
endloop

num i = 0
num j = 0
num number = 0
loop i < 5
    loop j < 4
        set number = number + 1
        set j = j + 1
    endloop
    set i = i + 1
    set j = 0
endloop
``` -->

<!-- #### Quickloop
Quickloops are different from standard loops in that the entire loop is executed *almost instantly*, while standard loops are executed one line at a time.

```
quickloop [loop iterations]
    [code]
endquickloop

quickloop 100
    out "hello"
endquickloop
-- outputs "hello" 100 times in a row
``` -->
## Program Data
<!-- ### Saving Data
Saves the contents of `[variable]` to the corresponding file in the `Config:/program_data` file. The key cannot contain spaces.
```
savedata [key] [value]
``` -->

### Loading Data
<!-- From the corresponding `Config:/program_data` file, loads the contents of entry of `[variable]` to the variable called `[variable]`
```
loaddata [variable] [key]
``` -->
## Imports
Imports are a way to extend the functionality of FroggyScript.

<!-- ### Import a Module
```
import [import name:S]

import "graphics"
``` -->
### Imports List & Documentation
* [graphics](https://rus1130.github.io/projects/mdparser.html?url=https://froggyos.github.io/versions/1.14/import-docs/graphics.md&toc=true)
* [config](https://rus1130.github.io/projects/mdparser.html?url=https://froggyos.github.io/versions/1.14/import-docs/config.md)
<!--
literally fucking everything

overhaul inclusions in translation descriptors
[T#:{value}]
# = number
this allows for multiple inclusions per descriptor
-->