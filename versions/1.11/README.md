# froggyOS Documentation

* in paths, `.` will be replaced with the current directory
* programs can *only* be written in designated directories
* you can press the `DEL` key to escape programs (ex. an infinite loop)
* press `SHIFT + ESC` to exit lilypad (text editor) without saving
* if a FroggyScript program exists with an error, the command `[[BULLFROG]]gotoprogramline [program] [line_with_error]` will be put into your command history

## Palette Conventions
There are no set colors that you must have, but these are the color conventions.
* `00` - black
* `01` - blue
* `02` - green
* `03` - cyan
* `04` - red
* `05` - magenta
* `06` - orange/brown
* `07` - light grey
* `08` - dark grey
* `09` - light blue
* `10` - light green
* `11` - light cyan
* `12` - light red
* `13` - light magenta
* `14` - light orange/yellow
* `15` - white

### Current Color Palettes
* standard
* revised
* cherry
* swamp
* swamp-revised
* neon

## Aliases

* changelanguage -> lang
* clear -> cl
* clearstate -> cls
* croak -> c
* formattime -> ft
* hatch -> ch
* help -> ?
* hop -> h
* list -> ls
* listdrives -> ld
* loadstate -> lds
* macro -> /
* meta -> m
* metaprop -> mp
* opendocumentation -> docs
* savestate -> svs
* spawn -> s
* swimto -> st

## Translating froggyOS into Different Languages
* The `lbh` file in the `Settings:/lang_files` directory is what holds the indexes for translation. **Do not edit this file unless you deliberately want to mess up froggyOS.**
    * Languages file names are 3 letter abbreviations of the language name.
* To add a new language, clone the `lbh`, or `language build helper` file, which contains **translation descriptors** (prefixed with `T_`), which give you an idea of what the intended meaning of the text.
* Set the language to `lbh` to see which translation descriptors are used where in froggyOS. If there are missing translation descriptors at the end of a file, the English translation will be used.
    * If a language file does not meet requirements (valid name declaration, correct file length), it will be invalid and unable to be used.
* The **name declaration** must be the first line of the file, and must be in the format `{{{LANGNAME_!!!_[language name]}}}`. For example, the name declaration for the `eng` file is `{{{LANGNAME_!!!_English}}}`.
* If the default language is invalid, froggyOS will automatically revert to the `lbh` language file.
* If a text results in `Index Missing! -> [translation descriptor]`, this means that the translation descriptor is missing from the language file.
* Some translation descriptors include `|||[]|||` in it. This must be included in order to reference the descriptor. This is because between the `[]` a string can be placed that will show in the final translation. For example, if you used `T_greeting_2 |||[3 million]|||`, it would return in the `eng` translation as `* Welcome to froggyOS, version 3 million *`.

## Command Help
### formattime
The all instances of the following characters (or character sequences) will be replaced with their respective values. Place a `!` before the character to escape it.
#### Date
* weekday
    * `w` - short weekday (Mon, Tues)
    * `W` - long weekday (Monday, Tuesday)
* `y` - year
* month
    * `mn` - month number (01, 02)
    * `mnu` - month number unpadded (1, 2)
    * `ms` - month short (Jan, Feb)
    * `M` - month long (January, February)
* day
    * `d` - day (01, 02)
    * `du` - day unpadded (1, 2)
    * `D` - ordinal day (1st, 2nd)

#### Time
* hour
    * `h` - 24 hour (00, 01, ... 22, 23)
    * `hu` - 24 hour unpadded (0, 1, ... 22, 23)
    * `H` - 12 hour (01, 02, ... 11, 12)
    * `Hu` - 12 hour unpadded (1, 2, ... 11, 12)
* minute
    * `m` - minute (00, 01)
    * `mu` - minute unpadded (0, 1)
* second
    * `s` - second (00, 01)
    * `su` - second unpadded (0, 1)
* `a` - AM/PM
* `z` - timezone

### hop
* `hop ~` will take you to the root directory of the current drive
* `hop -` will take you to the previous directory

### metaprop
Properties:
* read - If this file can be read. This includes being able to run the program or list file contents with the `spy` command.
    * when a file is cloned, this property will be set to `true`.
* write - If this file can be written to. This includes being able to edit the file or delete it.
    * when a file is cloned, this property will be set to `true`.
* hidden - If this file is hidden. This will *not* prevent you from editing the file.
* transparent - This file will not show in the directory or in lists, but can be acted upon.
    * when a file is cloned, this property will be set to `false`.

## Macros
* Macros are written in the `D:/Macros` directory
* each line in a macro file is a command that will be executed
* to add an alias to a macro, the **first** line must be `![alias]`. You can add only one alias per macro.
* to use file arguments inside of a macro, use `$[file argument number]`

## Settings Directory
If you edit the `Settings:` drive directly, some settings won't apply until you reload the froggyOS state. An easy way to do this would be to run the `reload` macro.

## Bugs
* you cannot set values to array indexes
* since the addition of methods, i think most types will not coalesce properly.
* In boolean expressions, cannot use methods on the left side of an operator

# FroggyScript Documentation
* `[argument="default_value"]` denotes a default argument value
* `:[character]` denotes a specific type input
    * `T` - placeholder; used in documentation **only** to show that the type should be specified
    * `*` - any type
    * `S` - String
    * `N` - Number
    * `B` - Boolean
    * `A` - Array
    * `U` - Undefined

## General Utilities

### End the Program
* An error **WILL** be thrown is this is not the last line of the program.
```
endprog
```
### Comments
```
-- comment!
```
### Wait
```
wait [time]

wait 1000
wait number
```
### Clear Screen
```
clearterminal
```
### Preset Variables
These variables are immutable.
```
true:B - true
false:B - false
Pi:N - 3.141592653589793
Time_MsEpoch:N - time since epoch (January 1, 1970) in milliseconds
Time_OSRuntime:N - OS uptime in milliseconds
Time_ProgramRuntime:N - program uptime in milliseconds
Undefined:U - undefined
```
## Variables
### Types
#### String
```
str [variable_name] = [value]

str test = 'single'
str test = "double"
str test = "multiple words"

-- string literals
int age = 20
str output = "i am $|age| years old"
```
#### Number
```
num [variable_name] = [value]

num i = 9
```
#### Boolean
```
-- boolean
bln [variable_name] = [value]

bln test = true
```
#### Array
* Indexing starts at `0`.
##### Named
```
arr [variable_name] = [value], [value], ...

arr test1 = 1, 2, 3, 4, 5
arr test2 = "a", "b", "c", "d", "e"
arr test3 = "a", 1, true, 2.5, "b"
```
##### Unnamed
* surrounding strings with `$` will force a type of `Array`.
```
out 'one', 'two', 'three'
-- one', 'two, 'three

out $'one', 'two', 'three'$
-- {{Array}}

str variable = "thirty three million"
out $variable, 'two', 'three'$>index(0)
-- thirty three million
```

### Edit a Variable
You may only edit a variable if the value is of the same type.
```
set [variable_name] = [value]

num i = 5
str test = "text"

set test = "many word"
set i = i + 1

set i = test
-- throws a TypeError
```

### Delete a Variable
```
free [variable_name]

free test
```

## Output
Automatically stringifies inputs.
### Basic Output
```
out [argument]

out variable_name
out "text"
out "more text"
out 1
```
### Formatted Output
#### General
* index `0` is the 1st character.
* There is less than normal error checking on formatting objects, so make sure they're correct.
```
outf [format] [text]

outf {t=c01} "this is blue text"
outf {b=c00} "this is a black background"
outf {t=c06, b=c01} "this is brown text on a blue background"
outf {t=c01, tr=0-21} "from char 0 to char 21, the text will be blue" 
outf {t=c01, tr=4-48 | b=c04, br=57-91} "from the char 4 to char 48, the text will be blue. AND from char 57 to char 91 the background will be red"
```
#### Format Object
* `{}` is a formatting object
* **rules** are delimited by the pipe operator: `{[property]=[value] | [property]=[value], [property]=[value]}`
* **subrules** are delimited by the comma operator, and occur inside of **rules**: `{[property]=[value],[property]=[value]}`
    * If a range is not specified, it will apply to the entire string
    * The value for Italic is `1` to be enabled, and `0` to be disabled
* valid properties:
    * `t` - text color
    * `b` - background color
    * `i` - italic
    * `tr` - text color range
    * `br` - background color range
    * `ir` - italic range

### Errors
Errors do not end the program early, follow with the `endprog` keyword to do so.
#### Basic Error
```
error [error_message]

error "this is an error message"

-- when ran
C:/Home> st [program_name]
!!ERROR!! - this is an error message
```
## Input
### Define a File Argument
File arguments are passed in the terminal when running the program. The `filearg` keyword will create an **immutable** variable with the provided keyword and cannot override other variable values, even if that variable is mutable.
```
filearg [variable_name] [type]

-- default usage
filearg name String
filearg age Number
out "hello I am $|name| and I am $|age| years old"
endprog

-- when running the program
C:/Home> st [program_name] [arg1] [arg2]
C:/Home> st about_froggy froggy 7
> hello I am froggy and I am 7 years old
```
### Typeable Input
```
ask [variable] [prefix='?']

ask name
ask name "custom"

-- default usage
str name = ""
out "What is your name?"
ask name
out 'Hello $|name|!'
endprog

-- in the terminal
C:/Home> st [program_name]
> What is your name?
? Froggy
> Hello Froggy!

-- custom prefix
str name = ""
out "What is your name?"
ask name "custom"
out 'Hello $|name|!'

-- in the terminal
C:/Home> st [program_name]
> What is your name?
custom Froggy
> Hello Froggy!
engprog

-- TypeError
num age = 0
out "How old are you?"
ask age
out 'You are $|age| years old.'
engprog

-- in the terminal
C:/Home> st [program_name]
> How old are you?
? Froggy
-- Throws a TypeError because [age] is type Number while the input for [ask] was type String
```

### Input with Navigable Options
```
prompt [variable:*] [default highlighted option:N] [options:A]

str output = ''
prompt output 0 $'hello', "world!", "I am froggy!"$
```

## Functions
### Create a Function
#### No Arguments
```
func [func_name]
    [code]
endfunc

func name
    out "hello"
endfunc
```
#### Arguments
```
func [func_name] [arg1:T] [arg2:T] ... [argN:T]
    [code]
endfunc

func name str:S
    out "hello $|str|!"
endfunc
```
#### Return Values
If the function ends in the keyword `return`, the value of whatever passed will be the return value.
```
func name
    return 5
endfunc

num i = @name
```
### Call a Function
#### No Arguments
```
@[func_name]

@name
```
#### Arguments
```
@[func_name]([arg1];[arg2];...;[argN])

@name("hello";"world!")
```

## Control Flow
### If Statement
```
if [condition]
    [code]
endif

if variable_name == "value"
    set variable_name = 'new value'
endif

if [condition]
    [if true]
else
    [if false]
endif

if variable_name == 4
    out "something"
else
    out "something else"
endif
```

### Loops
#### Standard Loop
```
loop [condition]
    [code]
endloop

loop i < 5
    out i
    set i = i + 1
endloop

num i = 0
num j = 0
num number = 0
loop i < 5
    loop j < 4
        set number = number + 1
        set j = j + 1
    endloop
    set i = i + 1
    set j = 0
endloop
```

#### Quickloop
Quickloops are different from standard loops in that the entire loop is executed *almost instantly*, while standard loops are executed one line at a time.

```
quickloop [loop_iterations]
    [code]
endquickloop

quickloop 100
    out "hello"
endquickloop
-- outputs "hello" 100 times in a row
```
## Method Keywords
### stringify
Converts a Number to a String
```
num test = 5
stringify 5
-- "5"
```
### append
Appends the second argument to the first argument. Both must be arrays.
```
arr test1 = "a", "b", "c"
arr test2 = 1, 2, 3
append test1 test2
-- "a", "b", "c", 1, 2, 3
```
## Methods
If no arguments are passed, you may omit the parentheses. Arguments are separated by `;`.
### index
Indexing starts at `0`.
```
arr test = "a", "b", "c", "d", "e"
str output = test>index(0)
-- "a"

arr test2 = 1, 2, 3, 4, 5
str output = test2>:(1)
-- "2"
```
### join
Join the elements of an array into a string, delimited by the provided separator. If no argument is passed, "," will be used instead.
```
arr test = "a", "b", "c", "d", "e"
str output =  test>join(" and ")
-- "a and b and c and d and e"

arr test2 = 1, 2, 3, 4, 5
str output = test2>join
-- "1,2,3,4,5"
```
### type
Outputs the type of the input as a string.
```
arr test = "a", "b", "c", "d", "e"
str output = test>type
-- "Array"

num test = 5
str output = test>type
-- "Number"
```
### length
Length of the input array or string.
```
arr test = "a", "b", "c", "d", "e"
num output = test>length
-- 5

str test = "hello world!"
num output = test>length
-- 12
```
### replace
Replace the first instance of the first argument with the second argument.
```
str test = "hello world!"
str output = test>replace("hello";"goodbye")
-- "goodbye world!"
```
### stringify
Converts a Number or Array to a String
```
num test = 5
str output = test>stringify
-- "5"
```
### append
```
arr letters = "a", "b", "c"
arr numbers = 1, 2, 3
out letters>append(numbers)
-- "a", "b", "c", 1, 2, 3
```
## Program Data
### Saving Data
Saves the contents of `[variable]` to the corresponding file in the `D:/Program-Data` file. The key cannot contain spaces.
```
savedata [key] [value]
```

### Loading Data
From the corresponding `D:/Program-Data` file, loads the contents of entry of `[variable]` to the variable called `[variable]`
```
loaddata [variable] [key]
```
