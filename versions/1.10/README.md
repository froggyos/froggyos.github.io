# Things to Know

* in paths, `.` will be replaced with the current directory
* programs can *only* be written in designated directories
* you can press the `DEL` key to escape programs (ex. an infinite loop)

## Palette Conventions
There are no set colors that you must have, but these are the color conventions.
* `00` - black, the void surrounding the terminal
* `01` - blue, the top bar background color
* `02` - green, text color, as well as selected text and option background color
* `03` - cyan
* `04` - red
* `05` - magenta, translation error color text background
* `06` - orange/brown
* `07` - light grey
* `08` - dark grey
* `09` - light blue
* `10` - light green
* `11` - light cyan
* `12` - light red, error background color
* `13` - light magenta
* `14` - light orange/yellow
* `15` - white, the terminal background color, top bar and error text color, and the selected text and option color

Note: colors `00`, `01`, `02`, `05`, `12`, and `15` are tied to their specific UI elements and this **cannot** be changed (yet). Some palettes are hardcoded to changes these values around. This will able to be done by the user via palette files in future versions.

### Current Color Palettes
* standard
* revised
* cherry
* swamp
* swamp-revised
* neon

## Aliases

* changelanguage -> lang
* clear -> cl
* clearstate -> cls
* croak -> c
* formattime -> ft
* hatch -> ch
* help -> ?
* hop -> h
* list -> ls
* listdrives -> ld
* loadstate -> lds
* macro -> /
* meta -> m
* metaprop -> mp
* opendocumentation -> docs
* savestate -> svs
* spawn -> s
* swimto -> st

## Translating froggyOS into Different Languages
* The `lbh` file in the `Settings:/lang_files` directory is what holds the indexes for translation. **Do not edit this file unless you deliberately want to mess up froggyOS.**
    * Languages file names are 3 letter abbreviations of the language name.
* To add a new language, clone the `lbh`, or `language build helper` file, which contains **translation descriptors** (prefixed with `T_`), which give you an idea of what the intended meaning of the text.
* Set the language to `lbh` to see which translation descriptors are used where in froggyOS. If there are missing translation descriptors at the end of a file, the English translation will be used.
    * If a language file does not meet requirements (valid name declaration, correct file length), it will be invalid and unable to be used.
* The **name declaration** must be the first line of the file, and must be in the format `{{{LANGNAME_!!!_[language name]}}}`. For example, the name declaration for the `eng` file is `{{{LANGNAME_!!!_English}}}`.
* If the default language is invalid, froggyOS will automatically revert to the `lbh` language file.
* If a supposedly translated text results in `Index Missing! -> [translation descriptor]`, this means that you ROYALLY screwed something up. This can only happen if you edit the `lbh` file. If you manage to trigger this error without editing this file through the dev console, please email what you did to `froggyos.royal.screw.up@gmail.com` so I can replicate it.
* Some translation descriptors include `|||[]|||` in it. This must be included in order to reference the descriptor. This is because between the `[]` a string can be placed that will show in the final translation. For example, if you used `T_greeting_2 |||[3 million]|||`, it would return in the `eng` translation as `* Welcome to froggyOS, version 3 million *`.

## Command Help
### formattime
The all instances of the following characters (or character sequences) will be replaced with their respective values. Place a `!` before the character to escape it.
#### Date
* weekday
    * `w` - short weekday (Mon, Tues)
    * `W` - long weekday (Monday, Tuesday)
* `y` - year
* month
    * `mn` - month number (01, 02)
    * `mnu` - month number unpadded (1, 2)
    * `ms` - month short (Jan, Feb)
    * `M` - month long (January, February)
* day
    * `d` - day (01, 02)
    * `du` - day unpadded (1, 2)
    * `D` - ordinal day (1st, 2nd)

#### Time
* hour
    * `h` - 24 hour (00, 01, ... 22, 23)
    * `hu` - 24 hour unpadded (0, 1, ... 22, 23)
    * `H` - 12 hour (01, 02, ... 11, 12)
    * `Hu` - 12 hour unpadded (1, 2, ... 11, 12)
* minute
    * `m` - minute (00, 01)
    * `mu` - minute unpadded (0, 1)
* second
    * `s` - second (00, 01)
    * `su` - second unpadded (0, 1)
* `a` - AM/PM
* `z` - timezone

### hop
* `hop ~` will take you to the root directory of the current drive
* `hop -` will take you to the previous directory

### metaprop
Properties:
* read - If this file can be read. This includes being able to run the program or list file contents with the `spy` command.
    * when a file is cloned, this property will be set to `true`.
* write - If this file can be written to. This includes being able to edit the file or delete it.
    * when a file is cloned, this property will be set to `true`.
* hidden - If this file is hidden. This will *not* prevent you from editing the file.
* transparent - This file will not show in the directory or in lists, but can be acted upon.
    * when a file is cloned, this property will be set to `false`.

## Macros
* Macros are written in the `D:/Macros` directory
* each line in a macro file is a command that will be executed
* to add an alias to a macro, the **first** line must be `![alias]`. You can add only one alias per macro.
* to use file arguments inside of a macro, use `$[file argument number]`

## Settings Directory
If you edit the `Settings:` drive directly, some settings won't apply until you reload the froggyOS state. An easy way to do this would be to run the `reload` macro.

## Bugs
* the loading spinner slows down with consecutive saves of a long file (?)

# FroggyScript2 Documentation
## General Utilities
### End the Program
An error **WILL** be thrown is this is not the last line of the program.
```
endprog
```
### Comments
```
-- comment!
```
### Wait
```
wait [time]

wait 1000
wait number
```
<!-- ### Clear Screen
```
clearterminal
``` -->
<!-- ### Change Color Palette
```
changepalette [palette name]

changepalette standard
changepalette cherry
``` -->
### String Literals
```
num age = 21 
out "I am $[24 - 3] years old"
out "I am $[age] years old"
```

## Output
### Basic Output
```
out [argument]

out variable_name
out "text"
out "more text"
out 1
```
<!-- ### Formatted Output
#### General
* index `0` is the 1st character.
* You can  use variables as values for color codes, variables of length 2 or less will be converted to color codes automatically.
* There is very little error checking on the formatting objects, so make sure they're correct.
* The whitespace inside of the formatting object does not matter.
```
outc [format] [text]

outc {t=c01} "this is blue text"
outc {b=c00} "this is a black background"
outc {t=c02, b=c01} "this is green green text on a blue background"
outc {t=c02, tr=0-15} "from the 1st to 16th character, the text will be blue" 
outc {t=c02, tr=4-26 | b=c04, br=57-71} "from the 5th to 29th character, the text will be blue. AND from the 58th to the 72nd character the background will be red" 
```
#### Format Object
* `{}` is a formatting object
* you can set a subrule using this general format: `{[property]=[value]}`
* valid properties:
    * `t` - text color
    * `b` - background color
    * `i` - italic
    * `tr` - text color range
    * `br` - background color range
    * `ir` - italic range
* you can set multiple subrules by separating them with commas: `{[property]=[value],[property]=[value]}`
* to set different ranges, separate subrules with a `|`: `{[property]=[value] | [property]=[value]}`
    * If a range is not specified, the subrule will apply to the entire string
    * The value for Italic is `1` to be enabled, and `0` to be disabled
  -->
## Variables
### Create a Variable

```
-- string
str [variable_name] = [value]
-- number
num [variable_name] = [value]
-- boolean
bln [variable_name] = [value]

str test = 'single'
str test = "double"
str test = "multiple words"

int age = 20
str output = "i am $[age] years old"
```
### Edit a Variable
```
set [variable_name] = [value]

num test = 5
str test = "text"

set test = "many word"
set i = i + 1

// throws a TypeError
set i = test
```

### Delete a Variable
```
free [variable_name]

free test
```
<!-- ## String Manipulation
### Append
```
append [variable] [value]

append test ing
append test ing the append keyword
append test ' ing it some more'
append test "AND MORE"
append test v:variable
``` -->
## User Input
### Define a File Argument
The `filearg` keyword will create an **immutable** variable with the provided keyword and cannot override other variable values.
```
filearg [variable_name] [type]
filearg name String
filearg age Number
out "hello I am [name] and I am [age] years old"

-- when running the program
C:/Home> st [program_name] [arg1] [arg2]
C:/Home> st about_froggy froggy 7
> hello I am froggy and I am 7 years old
```
### Typeable User Input
```
ask [variable]

ask name

-- example usage
str name = "";
out "What is your name?"
ask name
out 'Hello $[name]!'

-- when running the program
C:/Home> st [program_name]
> What is your name?
? Froggy
> Hello Froggy.
```
<!-- 
### User Input with Navigable Options
```
prompt [default highlighted option] [variable] [...options]

prompt 0 output 0 1 2 3
prompt highlightedOption outputVariable the_options cannot_have spaces_in them
``` -->

## Functions
### Create a Function
```
func [func_name]
    [code]
endfunc

func name
    out "hello"
endfunc
```
### Call a Function
```
f: [func_name]

f: name
```

## Control Flow
### If Statement
```
if [condition]
    [code]
endif

if variable_name == "value"
    set variable_name = 'new value'
endif

if [condition]
    [if true]
else
    [if false]
endif

if variable_name == 4
    out "something"
else
    out "something else"
endif
```

### Loops
#### Standard Loop
```
loop [condition]
    [code]
endloop

loop i < 5
    out i
    set i = i + 1
endloop

int i = 0
int j = 0
loop i < 5
    loop j < 4
        out i * j
        set j = j + 1
    endloop
    set i = i + 1
    set j = 0
endloop
```

#### Quickloop
Quickloops are different from standard loops in that the entire loop is executed *almost instantly*, while standard loops are executed one line at a time, which is around 1ms per line.

```
quickloop [loop_iterations]
    [code]
endquickloop

quickloop 100
    out "hello"
endquickloop
-- outputs "hello" 100 times in a row
```

<!-- ## Program Data
### Saving Data
Saves the contents of `[variable]` to the corresponding file in the `D:/Program-Data` file
```
savedata [variable]
```
### Loading Data
From the corresponding `D:/Program-Data` file, loads the contents of entry of `[variable]` to the variable called `[variable]`
```
loaddata [variable]
``` -->